c
args[:skip] && args[:limit]
args
c
!!(0 && nil)
0 && nil
args[:limit]
args[:skip]
args
args[:skip] && args[:limit]
c
args
c
args
c
**args
args
c
args[:skip] && args[:first]
args
args[:skip]
args[:first]
players.offset(args[:skip])
players
players.count
c
context[:queues][:create_notification]
context[:queues].key('create_notification')
context[:queues].key(:create_notification)
context[:queues]
continue
payload
continue
queue_params
payload
continue
next
continue
error
next
active_connection.queue_exists?
active_connection.status
connected?
active_connection.open?
active_connection
next
continue
active_connection.open?
active_connection.status
active_connection.exchanges
next
continue
next
error
next
@active_connection.closed?
active_connection
next
active_channel
active_channel&.open?
connected?
continue
@channel_singleton.instance.channel
2
@channel_singleton
channel
continue
queue_config
next
continue
exchange_name
queue_config
next
continue
config_file.dig(:exchanges)
exchange_name
context
queue
queue_name
config_file.dig(:exchanges, exchange_name.to_sym)
exchange_name
config_file.dig(:exchanges)
config_file
queue
context
exchange_name
queue
queue_config
next
context
exchange_name
next
continue
team.errors.full_messages
next
continue
next
continue
team.errors.full_messages
team
next
continue
player_id
c
player_id
continue
args
continue
next
c
player.tap { |player| player.update!(args.except(:id)) }
player
res
res = player.update!(args.except(:id))
next
res = player.update!(args.except(:id))
args.except(:id)
args
continue
player = ::Player.find(args[:id])
args
continue
args
c
args[:order_by].to_sym
args.to_sym
args
